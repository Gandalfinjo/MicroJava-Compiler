package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:
	boolean errorDetected;

	public void report_fatal_error(String message, Object info) throws java.lang.Exception {
		done_parsing();
		report_error(message, info);
	}
	
	public void syntax_error(Symbol cur_token) {
		report_error("\nSyntax error", cur_token);
	}
	
	public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
		report_fatal_error("Fatal error, parsing cannot continue.", cur_token);
	}
	
	public void report_error(String message, Object info) {
		errorDetected = true;
		
		StringBuilder msg = new StringBuilder(message);
		
		if (info instanceof Symbol)
			msg.append(" on the line ").append(((Symbol)info).left);
		
		System.err.println(msg.toString());
	}
:}

init with {:
	errorDetected = false;
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	
	if (s != null && s.value != null)
		System.out.println(s.toString() + " " + s.value.toString());
		
	return s;
:}

terminal PROG, BREAK, CLASS, IF, ELSE, CONST, NEW, PRINT;
terminal READ, RETURN, VOID, EXTENDS, CONTINUE, UNION, DO;
terminal WHILE, MAP, INTERFACE;
terminal PLUS, MINUS, STAR, SLASH, PERCENTAGE;
terminal EQUAL, NOT_EQUAL;
terminal HIGHER, HIGHER_EQUAL, LOWER, LOWER_EQUAL;
terminal AND, OR, ASSIGN, INCREMENT, DECREMENT;
terminal SEMICOLON, COLON, COMMA, DOT;
terminal OPEN_PARENTHESIS, CLOSED_PARENTHESIS;
terminal OPEN_BRACKET, CLOSED_BRACKET;
terminal OPEN_BRACE, CLOSED_BRACE;
terminal Boolean BOOL_CONST;
terminal Character CHAR_CONST;
terminal Integer NUMBER_CONST;
terminal String IDENT;

nonterminal Program;
nonterminal DeclList, Decl;
nonterminal VarDeclList, VarDeclExtendedList, VarDeclExtended;
nonterminal MethodDeclList;
nonterminal StatementList, Statement;
nonterminal DesignatorStatement, DesignatorStatementTail, DesignatorStatementList, DesignatorTail;
nonterminal ElseStatement;
nonterminal NumConstList;
nonterminal DoWhileOption;
nonterminal ActPars, ActParsOption, ActParsInner;
nonterminal FormPars, FormParamList, FormParamArray, FormParamExtendedList, FormParamExtended;
nonterminal ConstDeclValue, ConstDeclExtendedList, ConstDeclExtended;
nonterminal ClassMemberList, ClassMember;
nonterminal ExtendsType;
nonterminal InterfaceMemberList, InterfaceMember;
nonterminal CondFact, CondFactTail, CondTerm, CondFactList, Condition, CondTermList;
nonterminal ExprsExtended;
nonterminal MulopFactorList, MulopFactor;
nonterminal AddopTermList, AddopTerm;
nonterminal Label;
nonterminal Assignop, Relop, Addop, Mulop, Setop;

nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, Designator, MethodDecl, MethodSignature, ConstDecl, VarDecl, ClassDecl, InterfaceDecl;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, Term, Factor, Expr, NewFactorTail;

precedence left ELSE;

Program ::= (Program) PROG ProgName DeclList OPEN_BRACE MethodDeclList CLOSED_BRACE;

ProgName ::= (ProgName) IDENT:progName;

DeclList ::= (Declarations) DeclList Decl
				|
				(NoDeclarations) /* epsilon */
				;
Decl ::= (ConstD) ConstDecl
				|
				(VarD) VarDecl
				|
				(ClassD) ClassDecl
				|
				(InterfaceD) InterfaceDecl
				;

ConstDecl ::= (ConstDeclaration) CONST Type:type IDENT:name ASSIGN ConstDeclValue:value ConstDeclExtendedList:list SEMICOLON;
ConstDeclValue ::= (NumberConst) NUMBER_CONST
				|
				(CharConst) CHAR_CONST
				|
				(BoolConst) BOOL_CONST
				;
ConstDeclExtendedList ::= (ConstDeclarationsExtended) ConstDeclExtendedList ConstDeclExtended
				|
				(NoConstDeclarationsExtended) /* epsilon */
				;
ConstDeclExtended ::= (ConstDeclarationExtended) COMMA IDENT:name ASSIGN ConstDeclValue;

VarDeclList ::= (VarDeclarations) VarDeclList VarDecl
				|
				(NoVarDeclarations) /* epsilon */
				;
VarDecl ::= (VarDeclaration) Type:type IDENT:name VarDeclExtendedList:list SEMICOLON
				|
				(VarDeclarationArray) Type:type IDENT:name OPEN_BRACKET CLOSED_BRACKET VarDeclExtendedList:list SEMICOLON
				|
				(VarDeclError) error SEMICOLON:l {: parser.report_error("Error in variable declaration. Recovery until ';' on the line " + lleft, null); :}
				|
				(VarDeclErrorComma) error COMMA:l {: parser.report_error("Error in variable declaration. Recovery until ',' on the line " + lleft, null); :}
				|
				(VarDeclErrorBrace) error OPEN_BRACE:l {: parser.report_error("Error in variable declaration inside a class. Recovery until '{' on the line " + lleft, null); :}
				;
VarDeclExtendedList ::= (VarDeclarationsExtended) VarDeclExtendedList VarDeclExtended
				|
				(NoVarDeclarationsExtended) /* epsilon */
				;
VarDeclExtended ::= (VarDeclarationExtended) COMMA IDENT:name
				|
				(VarDeclarationExtendedArray) COMMA IDENT:name OPEN_BRACKET CLOSED_BRACKET
				;

ClassDecl ::= (ClassDeclaration) CLASS IDENT:name ExtendsType:ext OPEN_BRACE VarDeclList:vlist ClassMemberList:mlist CLOSED_BRACE;
ClassMemberList ::= (ClassMembers) OPEN_BRACE MethodDeclList CLOSED_BRACE
				| (NoClassMembers) /* epsilon */
				;
ExtendsType ::= (ClassExtension) EXTENDS Type
				|
				(NoClassExtension) /* epsilon */
				|
				(ExtendsTypeError) error OPEN_BRACE:l {: parser.report_error("Error in extending a class. Recovery until '{' on the line " + lleft, null); :}
				;

InterfaceDecl ::= (InterfaceDeclaration) INTERFACE IDENT:name OPEN_BRACE InterfaceMemberList:mlist CLOSED_BRACE;
InterfaceMemberList ::= (InterfaceMembers) InterfaceMemberList InterfaceMember
				|
				(NoInterfaceMembers) /* epsilon */
				;
InterfaceMember ::= (InterfaceMethodDeclaration) MethodDecl
	 			|
	 			(InterfaceMethodSignature) MethodSignature SEMICOLON
	 			;

MethodDeclList ::= (MethodDeclarations) MethodDeclList MethodDecl
				|
				(NoMethodDeclarations) /* epsilon */
				;
MethodDecl ::= (MethodDeclaration) MethodSignature VarDeclList OPEN_BRACE StatementList CLOSED_BRACE;
MethodSignature ::= (TypeMethodSignature) Type:type IDENT:name OPEN_PARENTHESIS FormPars:pars CLOSED_PARENTHESIS
				|
				(VoidMethodSignature) VOID IDENT:name OPEN_PARENTHESIS FormPars:pars CLOSED_PARENTHESIS
				;
				
FormPars ::= (FormParams) FormParamList
				|
				(NoFormParams) /* epsilon */
				;
FormParamList ::= (FormParamList) Type:type IDENT:name FormParamArray:arr FormParamExtendedList:elist;
FormParamArray ::= (FormArrayBrackets) OPEN_BRACKET CLOSED_BRACKET
				|
				(NoFormArrayBrackets) /* epsilon */
				;
FormParamExtendedList ::= (ExtendedFormParamList) FormParamExtendedList FormParamExtended
				|
				(NoExtendedFormParamList) /* epsilon */
				;
FormParamExtended ::= (FormParamExtendedNormal) COMMA Type:type IDENT:name
				|
				(FormParamExtendedArary) COMMA Type:type IDENT:name OPEN_BRACKET CLOSED_BRACKET
				|
				(FormParamExtendedErrorComma) error COMMA:l {: parser.report_error("Error in formal parameter. Recovery until ',' on the line " + lleft, null); :}
				|
				(FormParamExtendedErrorParen) error CLOSED_PARENTHESIS:l {: parser.report_error("Error in formal parameter. Recovery until ')' on the line " + lleft, null); :}
				;

Type ::= (Type) IDENT:typeName;

StatementList ::= (Statements) StatementList Statement
				|
				(NoStatements) /* epsilon */
				;
Statement ::= (DesignatorStmt) DesignatorStatement SEMICOLON
				|
				(IfStatement) IF OPEN_PARENTHESIS Condition CLOSED_PARENTHESIS Statement ElseStatement
				|
				(BreakStatement) BREAK SEMICOLON
				|
				(ContinueStatement) CONTINUE SEMICOLON
				|
				(ReturnStatement) RETURN SEMICOLON
				|
				(ReturnExprStatement) RETURN Expr SEMICOLON
				|
				(ReadStatement) READ OPEN_PARENTHESIS Designator CLOSED_PARENTHESIS SEMICOLON
				|
				(PrintStatement) PRINT OPEN_PARENTHESIS Expr NumConstList CLOSED_PARENTHESIS SEMICOLON
				|
				(DoWhileStatement) DO Statement WHILE OPEN_PARENTHESIS DoWhileOption CLOSED_PARENTHESIS SEMICOLON
				|
				(MultipleStatements) OPEN_BRACE StatementList CLOSED_BRACE
				;
				
ElseStatement ::= (YesElseStatement) ELSE Statement
				| 
				(NoElseStatement) /* epsilon */
				;
				
DoWhileOption ::= (YesDoWhileOption) Condition DesignatorStatementList
				|
				(NoDoWhileOption) /* epsilon */
				;
				
NumConstList ::= (NumConsts) COMMA NUMBER_CONST NumConstList
				|
				(NoNumConsts) /* epsilon */
				;
				
DesignatorStatement ::= (OptionalDesignatorStatement) Designator DesignatorStatementTail
				|
				(FixedDesignatorStatement) Designator Assignop Designator Setop Designator
				|
				(DesignatorStatementError) error SEMICOLON:l {: parser.report_error("Error in assign statement. Recovery until ';' on the line " + lleft, null); :}
				;
DesignatorStatementTail ::= (AssignopExprDSTail) Assignop Expr
				|
				(ActParsDSTail) OPEN_PARENTHESIS ActParsInner CLOSED_PARENTHESIS
				|
				(IncrementDSTail) INCREMENT
				|
				(DecrementDSTail) DECREMENT
				;
DesignatorStatementList ::= (DesignatorStatements) COMMA DesignatorStatement DesignatorStatementList
				|
				(NoDesignatorStatements) /* epsilon */
				;
				
ActPars ::= (ActParams) Expr ExprsExtended;
ActParsOption ::= (ActParamsOption) OPEN_PARENTHESIS ActParsInner CLOSED_PARENTHESIS
				|
				(NoActParamsOption) /* epsilon */
				;
ActParsInner ::= (ActParamsInner) ActPars
				|
				(NoActParamsInner) /* epsilon */
				;
				
Condition ::= (Condition) CondTerm CondTermList;
CondTermList ::= (CondTerms) OR CondTerm CondTermList
				|
				(NoCondTerms) /* epsilon */
				;
CondTerm ::= (CondTerm) CondFact CondFactList;
CondFactList ::= (CondFacts) AND CondFact CondFactList
				|
				(NoCondFacts) /* epsilon */
				;
CondFact ::= (CondFact) Expr CondFactTail;
CondFactTail ::= (RelopCondFactTail) Relop Expr
				|
				(NoCondFactTail) /* epsilon */
				;

ExprsExtended ::= (ExprsExtendedList) COMMA Expr ExprsExtended
				|
				(NoExprsExtendedList) /* epsilon */
				;		
Expr ::= (NoSignExpr) Term:term AddopTermList:alist
				|
				(NegativeSignExpr) MINUS Term:term AddopTermList:alist
				|
				(DesignatorExpr) Designator MAP Designator
				;
				
AddopTermList ::= (AddopTerms) AddopTermList AddopTerm
				|
				(NoAddopTerms) /* epsilon */
				;
AddopTerm ::= (AddopTerm) Addop Term;

Term ::= (Term) Factor MulopFactorList;

MulopFactorList ::= (MulopFactors) MulopFactorList MulopFactor
				|
				(NoMulopFactors) /* epsilon */
				;
MulopFactor ::= (MulopFactor) Mulop Factor;

Factor ::= (DesignatorFactor) Designator:des ActParsOption:pars
				|
				(NumFactor) NUMBER_CONST:num
				|
				(CharFactor) CHAR_CONST:ch
				|
				(BoolFactor) BOOL_CONST:bool
				|
				(NewFactor) NEW Type:type NewFactorTail:tail
				|
				(ExprFactor) OPEN_PARENTHESIS Expr:expr CLOSED_PARENTHESIS
				;
NewFactorTail ::= (ExprFactorTail) OPEN_BRACKET Expr CLOSED_BRACKET
				|
				(ActParsFactorTail) OPEN_PARENTHESIS ActParsInner CLOSED_PARENTHESIS
				;
				
Designator ::= (Designator) IDENT:name DesignatorTail;
DesignatorTail ::= (DotDesignatorTail) DOT IDENT:field DesignatorTail:tail
				|
				(ExprDesignatorTail) OPEN_BRACKET Expr:index CLOSED_BRACKET DesignatorTail:tail
				|
				(NoDesignatorTail) /* epsilon */
				;

Label ::= (Label) IDENT;

Assignop ::= (Assignop) ASSIGN;

Relop ::= (Equals) EQUAL
				| (NotEquals) NOT_EQUAL
				| (Higher) HIGHER
				| (HiglerEqual) HIGHER_EQUAL
				| (Lower) LOWER
				| (LowerEqual) LOWER_EQUAL
				;
				
Addop ::= (Plus) PLUS | (Minus) MINUS;

Mulop ::= (Multiplication) STAR | (Division) SLASH | (Modulo) PERCENTAGE;

Setop ::= (Setop) UNION;