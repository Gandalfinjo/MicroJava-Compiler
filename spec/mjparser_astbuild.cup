package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:
	public void report_fatal_error(String message, Object info) throws java.lang.Exception {
		done_parsing();
		report_error(message, info);
	}
	
	public void syntax_error(Symbol cur_token) {
		report_error("\nSyntax error", cur_token);
	}
	
	public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
		report_fatal_error("Fatal error, parsing cannot continue.", cur_token);
	}
	
	public void report_error(String message, Object info) {
		StringBuilder msg = new StringBuilder(message);
		
		if (info instanceof Symbol)
			msg.append(" on the line ").append(((Symbol)info).left);
		
		System.err.println(msg.toString());
	}
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	
	if (s != null && s.value != null)
		System.out.println(s.toString() + " " + s.value.toString());
		
	return s;
:}

terminal PROG, BREAK, CLASS, IF, ELSE, CONST, NEW, PRINT;
terminal READ, RETURN, VOID, EXTENDS, CONTINUE, UNION, DO;
terminal WHILE, MAP, INTERFACE;
terminal PLUS, MINUS, STAR, SLASH, PERCENTAGE;
terminal EQUAL, NOT_EQUAL;
terminal HIGHER, HIGHER_EQUAL, LOWER, LOWER_EQUAL;
terminal AND, OR, ASSIGN, INCREMENT, DECREMENT;
terminal SEMICOLON, COLON, COMMA, DOT;
terminal OPEN_PARENTHESIS, CLOSED_PARENTHESIS;
terminal OPEN_BRACKET, CLOSED_BRACKET;
terminal OPEN_BRACE, CLOSED_BRACE;
terminal Boolean BOOL_CONST;
terminal Character CHAR_CONST;
terminal Integer NUMBER_CONST;
terminal String IDENT;

nonterminal Program Program;
nonterminal DeclList DeclList;
nonterminal Decl Decl;
nonterminal VarDeclList VarDeclList;
nonterminal VarDeclExtendedList VarDeclExtendedList;
nonterminal VarDeclExtended VarDeclExtended;
nonterminal MethodDeclList MethodDeclList;
nonterminal StatementList StatementList;
nonterminal Statement Statement;
nonterminal DesignatorStatement DesignatorStatement;
nonterminal DesignatorStatementTail DesignatorStatementTail;
nonterminal DesignatorStatementList DesignatorStatementList;
nonterminal DesignatorTail DesignatorTail;
nonterminal ElseStatement ElseStatement;
nonterminal NumConstList NumConstList;
nonterminal DoWhileOption DoWhileOption;
nonterminal ActPars ActPars;
nonterminal ActParsOption ActParsOption;
nonterminal ActParsInner ActParsInner;
nonterminal FormPars FormPars;
nonterminal FormParamList FormParamList;
nonterminal FormParamArray FormParamArray;
nonterminal FormParamExtendedList FormParamExtendedList;
nonterminal FormParamExtended FormParamExtended;
nonterminal ConstDeclValue ConstDeclValue;
nonterminal ConstDeclExtendedList ConstDeclExtendedList;
nonterminal ConstDeclExtended ConstDeclExtended;
nonterminal ClassMemberList ClassMemberList;
nonterminal ClassMember ClassMember;
nonterminal ExtendsType ExtendsType;
nonterminal InterfaceMemberList InterfaceMemberList;
nonterminal InterfaceMember InterfaceMember;
nonterminal CondFact CondFact;
nonterminal CondFactTail CondFactTail;
nonterminal CondTerm CondTerm;
nonterminal CondFactList CondFactList;
nonterminal Condition Condition;
nonterminal CondTermList CondTermList;
nonterminal ExprsExtended ExprsExtended;
nonterminal MulopFactorList MulopFactorList;
nonterminal MulopFactor MulopFactor;
nonterminal AddopTermList AddopTermList;
nonterminal AddopTerm AddopTerm;
nonterminal Label Label;
nonterminal Assignop Assignop;
nonterminal Relop Relop;
nonterminal Addop Addop;
nonterminal Mulop Mulop;
nonterminal Setop Setop;

nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, Designator, MethodDecl, MethodSignature, ConstDecl, VarDecl, ClassDecl, InterfaceDecl;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, Term, Factor, Expr, NewFactorTail;

precedence left ELSE;

Program ::= (Program) PROG ProgName:P1 DeclList:D2 OPEN_BRACE MethodDeclList:M3 CLOSED_BRACE {: RESULT=new Program(P1, D2, M3); RESULT.setLine(P1left); :};

ProgName ::= (ProgName) IDENT:progName {: RESULT=new ProgName(progName); RESULT.setLine(progNameleft); :};

DeclList ::= (Declarations) DeclList:D1 Decl:D2 {: RESULT=new Declarations(D1, D2); RESULT.setLine(D1left); :}
				|
				(NoDeclarations) {: RESULT=new NoDeclarations(); :} /* epsilon */
				;
Decl ::= (ConstD) ConstDecl:C1 {: RESULT=new ConstD(C1); RESULT.setLine(C1left); :}
				|
				(VarD) VarDecl:V1 {: RESULT=new VarD(V1); RESULT.setLine(V1left); :}
				|
				(ClassD) ClassDecl:C1 {: RESULT=new ClassD(C1); RESULT.setLine(C1left); :}
				|
				(InterfaceD) InterfaceDecl:I1 {: RESULT=new InterfaceD(I1); RESULT.setLine(I1left); :}
				;

ConstDecl ::= (ConstDeclaration) CONST Type:type IDENT:name ASSIGN ConstDeclValue:value ConstDeclExtendedList:list SEMICOLON {: RESULT=new ConstDeclaration(type, name, value, list); RESULT.setLine(typeleft); :};
ConstDeclValue ::= (NumberConst) NUMBER_CONST:N1 {: RESULT=new NumberConst(N1); RESULT.setLine(N1left); :}
				|
				(CharConst) CHAR_CONST:C1 {: RESULT=new CharConst(C1); RESULT.setLine(C1left); :}
				|
				(BoolConst) BOOL_CONST:B1 {: RESULT=new BoolConst(B1); RESULT.setLine(B1left); :}
				;
ConstDeclExtendedList ::= (ConstDeclarationsExtended) ConstDeclExtendedList:C1 ConstDeclExtended:C2 {: RESULT=new ConstDeclarationsExtended(C1, C2); RESULT.setLine(C1left); :}
				|
				(NoConstDeclarationsExtended) {: RESULT=new NoConstDeclarationsExtended(); :} /* epsilon */
				;
ConstDeclExtended ::= (ConstDeclarationExtended) COMMA IDENT:name ASSIGN ConstDeclValue:C1 {: RESULT=new ConstDeclarationExtended(name, C1); RESULT.setLine(nameleft); :};

VarDeclList ::= (VarDeclarations) VarDeclList:V1 VarDecl:V2 {: RESULT=new VarDeclarations(V1, V2); RESULT.setLine(V1left); :}
				|
				(NoVarDeclarations) {: RESULT=new NoVarDeclarations(); :} /* epsilon */
				;
VarDecl ::= (VarDeclaration) Type:type IDENT:name VarDeclExtendedList:list SEMICOLON {: RESULT=new VarDeclaration(type, name, list); RESULT.setLine(typeleft); :}
				|
				(VarDeclarationArray) Type:type IDENT:name OPEN_BRACKET CLOSED_BRACKET VarDeclExtendedList:list SEMICOLON {: RESULT=new VarDeclarationArray(type, name, list); RESULT.setLine(typeleft); :}
				|
				(VarDeclError) error SEMICOLON:l {: parser.report_error("Error in variable declaration. Recovery until ';' on the line " + lleft, null); :} {: RESULT=new VarDeclError(); :}
				|
				(VarDeclErrorComma) error COMMA:l {: parser.report_error("Error in variable declaration. Recovery until ',' on the line " + lleft, null); :} {: RESULT=new VarDeclErrorComma(); :}
				|
				(VarDeclErrorBrace) error OPEN_BRACE:l {: parser.report_error("Error in variable declaration inside a class. Recovery until '{' on the line " + lleft, null); :} {: RESULT=new VarDeclErrorBrace(); :}
				;
VarDeclExtendedList ::= (VarDeclarationsExtended) VarDeclExtendedList:V1 VarDeclExtended:V2 {: RESULT=new VarDeclarationsExtended(V1, V2); RESULT.setLine(V1left); :}
				|
				(NoVarDeclarationsExtended) {: RESULT=new NoVarDeclarationsExtended(); :} /* epsilon */
				;
VarDeclExtended ::= (VarDeclarationExtended) COMMA IDENT:name {: RESULT=new VarDeclarationExtended(name); RESULT.setLine(nameleft); :}
				|
				(VarDeclarationExtendedArray) COMMA IDENT:name OPEN_BRACKET CLOSED_BRACKET {: RESULT=new VarDeclarationExtendedArray(name); RESULT.setLine(nameleft); :}
				;

ClassDecl ::= (ClassDeclaration) CLASS IDENT:name ExtendsType:ext OPEN_BRACE VarDeclList:vlist ClassMemberList:mlist CLOSED_BRACE {: RESULT=new ClassDeclaration(name, ext, vlist, mlist); RESULT.setLine(nameleft); :};
ClassMemberList ::= (ClassMembers) OPEN_BRACE MethodDeclList:M1 CLOSED_BRACE {: RESULT=new ClassMembers(M1); RESULT.setLine(M1left); :}
				| (NoClassMembers) {: RESULT=new NoClassMembers(); :} /* epsilon */
				;
ExtendsType ::= (ClassExtension) EXTENDS Type:T1 {: RESULT=new ClassExtension(T1); RESULT.setLine(T1left); :}
				|
				(NoClassExtension) {: RESULT=new NoClassExtension(); :} /* epsilon */
				|
				(ExtendsTypeError) error OPEN_BRACE:l {: parser.report_error("Error in extending a class. Recovery until '{' on the line " + lleft, null); :} {: RESULT=new ExtendsTypeError(); :}
				;

InterfaceDecl ::= (InterfaceDeclaration) INTERFACE IDENT:name OPEN_BRACE InterfaceMemberList:mlist CLOSED_BRACE {: RESULT=new InterfaceDeclaration(name, mlist); RESULT.setLine(nameleft); :};
InterfaceMemberList ::= (InterfaceMembers) InterfaceMemberList:I1 InterfaceMember:I2 {: RESULT=new InterfaceMembers(I1, I2); RESULT.setLine(I1left); :}
				|
				(NoInterfaceMembers) {: RESULT=new NoInterfaceMembers(); :} /* epsilon */
				;
InterfaceMember ::= (InterfaceMethodDeclaration) MethodDecl:M1 {: RESULT=new InterfaceMethodDeclaration(M1); RESULT.setLine(M1left); :}
	 			|
	 			(InterfaceMethodSignature) MethodSignature:M1 SEMICOLON {: RESULT=new InterfaceMethodSignature(M1); RESULT.setLine(M1left); :}
	 			;

MethodDeclList ::= (MethodDeclarations) MethodDeclList:M1 MethodDecl:M2 {: RESULT=new MethodDeclarations(M1, M2); RESULT.setLine(M1left); :}
				|
				(NoMethodDeclarations) {: RESULT=new NoMethodDeclarations(); :} /* epsilon */
				;
MethodDecl ::= (MethodDeclaration) MethodSignature:M1 VarDeclList:V2 OPEN_BRACE StatementList:S3 CLOSED_BRACE {: RESULT=new MethodDeclaration(M1, V2, S3); RESULT.setLine(M1left); :};
MethodSignature ::= (TypeMethodSignature) Type:type IDENT:name OPEN_PARENTHESIS FormPars:pars CLOSED_PARENTHESIS {: RESULT=new TypeMethodSignature(type, name, pars); RESULT.setLine(typeleft); :}
				|
				(VoidMethodSignature) VOID IDENT:name OPEN_PARENTHESIS FormPars:pars CLOSED_PARENTHESIS {: RESULT=new VoidMethodSignature(name, pars); RESULT.setLine(nameleft); :}
				;
				
FormPars ::= (FormParams) FormParamList:F1 {: RESULT=new FormParams(F1); RESULT.setLine(F1left); :}
				|
				(NoFormParams) {: RESULT=new NoFormParams(); :} /* epsilon */
				;
FormParamList ::= (FormParamList) Type:type IDENT:name FormParamArray:arr FormParamExtendedList:elist {: RESULT=new FormParamList(type, name, arr, elist); RESULT.setLine(typeleft); :};
FormParamArray ::= (FormArrayBrackets) OPEN_BRACKET CLOSED_BRACKET {: RESULT=new FormArrayBrackets(); :}
				|
				(NoFormArrayBrackets) {: RESULT=new NoFormArrayBrackets(); :} /* epsilon */
				;
FormParamExtendedList ::= (ExtendedFormParamList) FormParamExtendedList:F1 FormParamExtended:F2 {: RESULT=new ExtendedFormParamList(F1, F2); RESULT.setLine(F1left); :}
				|
				(NoExtendedFormParamList) {: RESULT=new NoExtendedFormParamList(); :} /* epsilon */
				;
FormParamExtended ::= (FormParamExtendedNormal) COMMA Type:type IDENT:name {: RESULT=new FormParamExtendedNormal(type, name); RESULT.setLine(typeleft); :}
				|
				(FormParamExtendedArary) COMMA Type:type IDENT:name OPEN_BRACKET CLOSED_BRACKET {: RESULT=new FormParamExtendedArary(type, name); RESULT.setLine(typeleft); :}
				|
				(FormParamExtendedErrorComma) error COMMA:l {: parser.report_error("Error in formal parameter. Recovery until ',' on the line " + lleft, null); :} {: RESULT=new FormParamExtendedErrorComma(); :}
				|
				(FormParamExtendedErrorParen) error CLOSED_PARENTHESIS:l {: parser.report_error("Error in formal parameter. Recovery until ')' on the line " + lleft, null); :} {: RESULT=new FormParamExtendedErrorParen(); :}
				;

Type ::= (Type) IDENT:typeName {: RESULT=new Type(typeName); RESULT.setLine(typeNameleft); :};

StatementList ::= (Statements) StatementList:S1 Statement:S2 {: RESULT=new Statements(S1, S2); RESULT.setLine(S1left); :}
				|
				(NoStatements) {: RESULT=new NoStatements(); :} /* epsilon */
				;
Statement ::= (DesignatorStmt) DesignatorStatement:D1 SEMICOLON {: RESULT=new DesignatorStmt(D1); RESULT.setLine(D1left); :}
				|
				(IfStatement) IF OPEN_PARENTHESIS Condition:C1 CLOSED_PARENTHESIS Statement:S2 ElseStatement:E3 {: RESULT=new IfStatement(C1, S2, E3); RESULT.setLine(C1left); :}
				|
				(BreakStatement) BREAK SEMICOLON {: RESULT=new BreakStatement(); :}
				|
				(ContinueStatement) CONTINUE SEMICOLON {: RESULT=new ContinueStatement(); :}
				|
				(ReturnStatement) RETURN SEMICOLON {: RESULT=new ReturnStatement(); :}
				|
				(ReturnExprStatement) RETURN Expr:E1 SEMICOLON {: RESULT=new ReturnExprStatement(E1); RESULT.setLine(E1left); :}
				|
				(ReadStatement) READ OPEN_PARENTHESIS Designator:D1 CLOSED_PARENTHESIS SEMICOLON {: RESULT=new ReadStatement(D1); RESULT.setLine(D1left); :}
				|
				(PrintStatement) PRINT OPEN_PARENTHESIS Expr:E1 NumConstList:N2 CLOSED_PARENTHESIS SEMICOLON {: RESULT=new PrintStatement(E1, N2); RESULT.setLine(E1left); :}
				|
				(DoWhileStatement) DO Statement:S1 WHILE OPEN_PARENTHESIS DoWhileOption:D2 CLOSED_PARENTHESIS SEMICOLON {: RESULT=new DoWhileStatement(S1, D2); RESULT.setLine(S1left); :}
				|
				(MultipleStatements) OPEN_BRACE StatementList:S1 CLOSED_BRACE {: RESULT=new MultipleStatements(S1); RESULT.setLine(S1left); :}
				;
				
ElseStatement ::= (YesElseStatement) ELSE Statement:S1 {: RESULT=new YesElseStatement(S1); RESULT.setLine(S1left); :}
				| 
				(NoElseStatement) {: RESULT=new NoElseStatement(); :} /* epsilon */
				;
				
DoWhileOption ::= (YesDoWhileOption) Condition:C1 DesignatorStatementList:D2 {: RESULT=new YesDoWhileOption(C1, D2); RESULT.setLine(C1left); :}
				|
				(NoDoWhileOption) {: RESULT=new NoDoWhileOption(); :} /* epsilon */
				;
				
NumConstList ::= (NumConsts) COMMA NUMBER_CONST:N1 NumConstList:N2 {: RESULT=new NumConsts(N1, N2); RESULT.setLine(N1left); :}
				|
				(NoNumConsts) {: RESULT=new NoNumConsts(); :} /* epsilon */
				;
				
DesignatorStatement ::= (OptionalDesignatorStatement) Designator:D1 DesignatorStatementTail:D2 {: RESULT=new OptionalDesignatorStatement(D1, D2); RESULT.setLine(D1left); :}
				|
				(FixedDesignatorStatement) Designator:D1 Assignop:A2 Designator:D3 Setop:S4 Designator:D5 {: RESULT=new FixedDesignatorStatement(D1, A2, D3, S4, D5); RESULT.setLine(D1left); :}
				|
				(DesignatorStatementError) error SEMICOLON:l {: parser.report_error("Error in assign statement. Recovery until ';' on the line " + lleft, null); :} {: RESULT=new DesignatorStatementError(); :}
				;
DesignatorStatementTail ::= (AssignopExprDSTail) Assignop:A1 Expr:E2 {: RESULT=new AssignopExprDSTail(A1, E2); RESULT.setLine(A1left); :}
				|
				(ActParsDSTail) OPEN_PARENTHESIS ActParsInner:A1 CLOSED_PARENTHESIS {: RESULT=new ActParsDSTail(A1); RESULT.setLine(A1left); :}
				|
				(IncrementDSTail) INCREMENT {: RESULT=new IncrementDSTail(); :}
				|
				(DecrementDSTail) DECREMENT {: RESULT=new DecrementDSTail(); :}
				;
DesignatorStatementList ::= (DesignatorStatements) COMMA DesignatorStatement:D1 DesignatorStatementList:D2 {: RESULT=new DesignatorStatements(D1, D2); RESULT.setLine(D1left); :}
				|
				(NoDesignatorStatements) {: RESULT=new NoDesignatorStatements(); :} /* epsilon */
				;
				
ActPars ::= (ActParams) Expr:E1 ExprsExtended:E2 {: RESULT=new ActParams(E1, E2); RESULT.setLine(E1left); :};
ActParsOption ::= (ActParamsOption) OPEN_PARENTHESIS ActParsInner:A1 CLOSED_PARENTHESIS {: RESULT=new ActParamsOption(A1); RESULT.setLine(A1left); :}
				|
				(NoActParamsOption) {: RESULT=new NoActParamsOption(); :} /* epsilon */
				;
ActParsInner ::= (ActParamsInner) ActPars:A1 {: RESULT=new ActParamsInner(A1); RESULT.setLine(A1left); :}
				|
				(NoActParamsInner) {: RESULT=new NoActParamsInner(); :} /* epsilon */
				;
				
Condition ::= (Condition) CondTerm:C1 CondTermList:C2 {: RESULT=new Condition(C1, C2); RESULT.setLine(C1left); :};
CondTermList ::= (CondTerms) OR CondTerm:C1 CondTermList:C2 {: RESULT=new CondTerms(C1, C2); RESULT.setLine(C1left); :}
				|
				(NoCondTerms) {: RESULT=new NoCondTerms(); :} /* epsilon */
				;
CondTerm ::= (CondTerm) CondFact:C1 CondFactList:C2 {: RESULT=new CondTerm(C1, C2); RESULT.setLine(C1left); :};
CondFactList ::= (CondFacts) AND CondFact:C1 CondFactList:C2 {: RESULT=new CondFacts(C1, C2); RESULT.setLine(C1left); :}
				|
				(NoCondFacts) {: RESULT=new NoCondFacts(); :} /* epsilon */
				;
CondFact ::= (CondFact) Expr:E1 CondFactTail:C2 {: RESULT=new CondFact(E1, C2); RESULT.setLine(E1left); :};
CondFactTail ::= (RelopCondFactTail) Relop:R1 Expr:E2 {: RESULT=new RelopCondFactTail(R1, E2); RESULT.setLine(R1left); :}
				|
				(NoCondFactTail) {: RESULT=new NoCondFactTail(); :} /* epsilon */
				;

ExprsExtended ::= (ExprsExtendedList) COMMA Expr:E1 ExprsExtended:E2 {: RESULT=new ExprsExtendedList(E1, E2); RESULT.setLine(E1left); :}
				|
				(NoExprsExtendedList) {: RESULT=new NoExprsExtendedList(); :} /* epsilon */
				;		
Expr ::= (NoSignExpr) Term:term AddopTermList:alist {: RESULT=new NoSignExpr(term, alist); RESULT.setLine(termleft); :}
				|
				(NegativeSignExpr) MINUS Term:term AddopTermList:alist {: RESULT=new NegativeSignExpr(term, alist); RESULT.setLine(termleft); :}
				|
				(DesignatorExpr) Designator:D1 MAP Designator:D2 {: RESULT=new DesignatorExpr(D1, D2); RESULT.setLine(D1left); :}
				;
				
AddopTermList ::= (AddopTerms) AddopTermList:A1 AddopTerm:A2 {: RESULT=new AddopTerms(A1, A2); RESULT.setLine(A1left); :}
				|
				(NoAddopTerms) {: RESULT=new NoAddopTerms(); :} /* epsilon */
				;
AddopTerm ::= (AddopTerm) Addop:A1 Term:T2 {: RESULT=new AddopTerm(A1, T2); RESULT.setLine(A1left); :};

Term ::= (Term) Factor:F1 MulopFactorList:M2 {: RESULT=new Term(F1, M2); RESULT.setLine(F1left); :};

MulopFactorList ::= (MulopFactors) MulopFactorList:M1 MulopFactor:M2 {: RESULT=new MulopFactors(M1, M2); RESULT.setLine(M1left); :}
				|
				(NoMulopFactors) {: RESULT=new NoMulopFactors(); :} /* epsilon */
				;
MulopFactor ::= (MulopFactor) Mulop:M1 Factor:F2 {: RESULT=new MulopFactor(M1, F2); RESULT.setLine(M1left); :};

Factor ::= (DesignatorFactor) Designator:des ActParsOption:pars {: RESULT=new DesignatorFactor(des, pars); RESULT.setLine(desleft); :}
				|
				(NumFactor) NUMBER_CONST:num {: RESULT=new NumFactor(num); RESULT.setLine(numleft); :}
				|
				(CharFactor) CHAR_CONST:ch {: RESULT=new CharFactor(ch); RESULT.setLine(chleft); :}
				|
				(BoolFactor) BOOL_CONST:bool {: RESULT=new BoolFactor(bool); RESULT.setLine(boolleft); :}
				|
				(NewFactor) NEW Type:type NewFactorTail:tail {: RESULT=new NewFactor(type, tail); RESULT.setLine(typeleft); :}
				|
				(ExprFactor) OPEN_PARENTHESIS Expr:expr CLOSED_PARENTHESIS {: RESULT=new ExprFactor(expr); RESULT.setLine(exprleft); :}
				;
NewFactorTail ::= (ExprFactorTail) OPEN_BRACKET Expr:E1 CLOSED_BRACKET {: RESULT=new ExprFactorTail(E1); RESULT.setLine(E1left); :}
				|
				(ActParsFactorTail) OPEN_PARENTHESIS ActParsInner:A1 CLOSED_PARENTHESIS {: RESULT=new ActParsFactorTail(A1); RESULT.setLine(A1left); :}
				;
				
Designator ::= (Designator) IDENT:name DesignatorTail:D1 {: RESULT=new Designator(name, D1); RESULT.setLine(nameleft); :};
DesignatorTail ::= (DotDesignatorTail) DOT IDENT:field DesignatorTail:tail {: RESULT=new DotDesignatorTail(field, tail); RESULT.setLine(fieldleft); :}
				|
				(ExprDesignatorTail) OPEN_BRACKET Expr:index CLOSED_BRACKET DesignatorTail:tail {: RESULT=new ExprDesignatorTail(index, tail); RESULT.setLine(indexleft); :}
				|
				(NoDesignatorTail) {: RESULT=new NoDesignatorTail(); :} /* epsilon */
				;

Label ::= (Label) IDENT:I1 {: RESULT=new Label(I1); RESULT.setLine(I1left); :};

Assignop ::= (Assignop) ASSIGN {: RESULT=new Assignop(); :};

Relop ::= (Equals) EQUAL {: RESULT=new Equals(); :}
				| (NotEquals) NOT_EQUAL {: RESULT=new NotEquals(); :}
				| (Higher) HIGHER {: RESULT=new Higher(); :}
				| (HiglerEqual) HIGHER_EQUAL {: RESULT=new HiglerEqual(); :}
				| (Lower) LOWER {: RESULT=new Lower(); :}
				| (LowerEqual) LOWER_EQUAL {: RESULT=new LowerEqual(); :}
				;
				
Addop ::= (Plus) PLUS {: RESULT=new Plus(); :} | (Minus) MINUS {: RESULT=new Minus(); :};

Mulop ::= (Multiplication) STAR {: RESULT=new Multiplication(); :} | (Division) SLASH {: RESULT=new Division(); :} | (Modulo) PERCENTAGE {: RESULT=new Modulo(); :};

Setop ::= (Setop) UNION {: RESULT=new Setop(); :};